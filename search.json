[{"title":"ItemTouchHelper的简单应用","url":"/2020/use_itemtouchhelper_simplely/","content":"\n新需求，表格显示照片，并可以拖动排序。\n第一反应，RecyclerView啊。那拖动怎么办？搜了一下，系统提供了ItemTouchHelper，直接用就行了。下面简单记录一下使用方法，及过程中遇到的一些问题。\n\n## 使用方法\n### 首先先写好一个RecyclerView。\n以下是adapter的关键代码：固定第一个item用来显示拍照，其他item显示传入的数据\n```Kotlin\noverride fun getItemCount(): Int {\n    //加一显示第一个拍照item\n  return 1 + if (dataArray.isNullOrEmpty()) {\n        0\n  } else {\n        dataArray.size\n  }\n}\n\noverride fun onBindViewHolder(holder: ViewHolder, position: Int) {\n    //第一个固定显示拍照\n  if (position == 0) {\n        holder.tv_content.text = \"拍照\"\n  holder.tv_content.setBackgroundColor(\n            ContextCompat.getColor(\n                holder.itemView.context,\n                android.R.color.black\n  )\n        )\n        return\n  }\n\n    val dataPos = position - 1;\n    val text = dataArray[dataPos][0].toString()\n    val bgColor = ContextCompat.getColor(\n        holder.itemView.context,\n        dataArray[dataPos][1]\n    )\n    holder.tv_content.text = text\n    holder.tv_content.setBackgroundColor(bgColor)\n}\n```\n\n### 将ItemTouchHelper附加到RecyclerView上\n那我们就需要new一个ItemTouchHelper，而ItemTouchHelper需要传入一个ItemTouchHelper.Callback，接下来新建一个类继承子ItemTouchHelper.Callback\n```Kotlin\nclass MyItemTouchHelperCallback(val listener: MyTouchHelperListener) : ItemTouchHelper.Callback() {\n    override fun getMovementFlags(\n        recyclerView: RecyclerView,\n        viewHolder: RecyclerView.ViewHolder\n    ): Int {\n        val dragFlags =\n            ItemTouchHelper.UP or ItemTouchHelper.DOWN or ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT\n        val swipeFlags = ItemTouchHelper.LEFT\n        return makeMovementFlags(dragFlags, 0)\n    }\n\n    override fun onMove(\n        recyclerView: RecyclerView,\n        viewHolder: RecyclerView.ViewHolder,\n        target: RecyclerView.ViewHolder\n    ): Boolean {\n        listener?.onMove(viewHolder.adapterPosition, target.adapterPosition)\n        return true\n  }\n\n    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {\n    }\n\n    interface MyTouchHelperListener {\n        fun onMove(fromPos: Int, toPos: Int)\n    }\n}\n```\n必须重写3个方法：\n1. getMovementFlags\n控制Item往哪些方向可以拖，往哪些方向可以滑\n2. onMove\nItem移动的时候会被调用。我们在这里把它传到adapter里面，进行Item的交换。创建Listener，并在adapter里面实现\n```Kotlin\nclass ListAdapter(private val dataArray: Array<Array<Int>>) :\n    RecyclerView.Adapter<ListAdapter.ViewHolder>(),\n    MyItemTouchHelperCallback.MyTouchHelperListener {\n    //省略\n    override fun onMove(fromPos: Int, toPos: Int) {\n        notifyItemMoved(fromPos, toPos)\n    }\n}\n```\n3. onSwiped\nItem滑动的时候被调用。这个例子用不到。\n最后再把ItemTouchHelp附加到RecyclerView上\n```Kotlin\nItemTouchHelper(MyItemTouchHelperCallback(listAdapter)).attachToRecyclerView(rv_list)\n```\n\n好的，到这里为止，我们已经实现了拖拽交换item了。那么接下来还有哪些问题呢？\n\n## 各种问题\n\n### onMove一直被调用\n拖拽交换item不是UI交换就完事了，数据也是需要变的。然而我们发现这个onMove方法一直在调用，本地临时数据倒无所谓，一直更改也没什么，但是我们是需要提交网络的，总不能一直提交吧？\n重写ItemTouchHelper.Callback的clearView方法，这个方法会在所有手势和动画完成之后被调用，第一次onMove的时候记录开始的位置，clearView的时候记录结束的位置，然后再处理数据。\nMyItemTouchHelperCallback\n```Kotlin\noverride fun clearView(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder) {\n    super.clearView(recyclerView, viewHolder)\n    listener.onEnd(viewHolder.adapterPosition)\n}\n\ninterface MyTouchHelperListener {\n    fun onMove(fromPos: Int, toPos: Int)\n    fun onEnd(endPos: Int)\n}\n```\nListAdapter\n```Kotlin\nprivate var startDataPos = -1 \nprivate var endDataPos = -1 \noverride fun onMove(fromPos: Int, toPos: Int) {\n    notifyItemMoved(fromPos, toPos)\n    startDataPos = fromPos - 1\n}\n\noverride fun onEnd(endPos: Int) {\n    endDataPos = endPos - 1;\n    //处理数据，脚标归零\n    dataArray[startDataPos] = dataArray[endDataPos].also {\n      dataArray[endDataPos] = dataArray[startDataPos]\n    }\n    startDataPos = 0\n    endDataPos = 0 \n}\n```\n\n### 第一个item不能拖动\n第一个位置是用来显示拍照的，不能和普通照片一样被拖动，怎么办？\n两个办法：\n1. 在getMovementFlags里面判断，根据MyTouchHelperListener新增一个方法通过ListAdapter返回bool值，或者根据viewHolder的位置，来判断能不能拖拽。\n2. 重写ItemTouchHelper.Callback的isLongPressDragEnabled方法，返回false，禁止长按拖拽。再给item添加长按事件，调用ItemTouchHelper.startDrag来开启拖拽。\n\n### 第一个item不能被移动\n第一个位置同样不应该能被其他的item挤走，怎么办？\n这个好说，也是两个办法：\n1. 重写canDragOver，返回false即可。具体什么时候返回false，参考上面一个问题的方法1\n2. 更简单一点，接收到toPos是0，就不交换UI\n\n### 怎么在长按的时候显示删除按钮\n要求长按的时候，不仅可以拖动，而且在所有item的右上角显示删除按钮，就像手机桌面一样，怎么整？\n更改flag值，notifydatachanged？肯定不行啊，这个方法要把所有item重新测量，布局的，拖拽的手势就打断了，item就回到原位了，而且整个RecyclerView都会闪一下。\n解决办法就是，先默认不允许长按拖动，再监听item的长按事件，长按的时候调用ItemTouchHelper.startDrag来开启拖拽。那怎么显示删除按钮呢？直接用RecyclerView来获取所有ViewHolder，直接操作ViewHolder，显示出删除按钮。\n\n---\n好的，以上就是我这次使用ItemTouchHelper的过程了。\ndemo代码在这里[https://github.com/chenyue404/ItemTouchHelperDemo](https://github.com/chenyue404/ItemTouchHelperDemo)","tags":["Android"],"categories":["开发"]},{"title":"Android上各种App的去广告姿势","url":"/2020/remove_app_ads_on_android/","content":"## Adguard\n```\n||pstatp.com/obj/ad-pattern^\n||snssdk.com/api/ad^\n||api.xiachufang.com/v2/ad^\n||restapi.ele.me/lego/new_splash_screen^\n```\n\n## host\nAdAday的默认列表先来一个\n\n| 应用 | 域名 |\n| --- | --- |\n|铁路12306|ad.12306.cn|\n|搜书大师|snssdk.com|\n|下厨房|api.xiachufang.com/v2/ad/*|\n\n## Activity\n```shell\nadb shell am start -n *\n```\n| 应用 | Activity | 是否需要root |\n| --- | --- | --- |\n|搜书大师|com.flyersoft.seekbooks/com.flyersoft.seekbooks.ActivityMain|是|\n|饿了么|me.ele/me.ele.application.ui.home.HomeActivity|是|\n|招商银行|长按图标，点击“账户”进入|否|\n|     |浏览器打开`javascript:window.location.href='cmbmobilebank://cmbls/functionjump?id=1&action=gofuncid&funcid=6001003&keeponPath=true&source=today';`|否 |","tags":["Android"],"categories":["玩机"]},{"title":"不知道第几个博客","url":"/2020/zero/","content":"已经记不得是第几个blog了，建了，死了，不管了。这个还是好好写吧。\nmarkdown，简简单单地写。","categories":["日常"]}]