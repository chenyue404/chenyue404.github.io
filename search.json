[{"title":"Android手机通过USB线连接电脑上网","url":"/2024/install_magisk_on_avd/","content":"\n很久以前写过一篇博客介绍如何让[Android设备通过USB线连接电脑网络](https://chenyue404.blogspot.com/2018/08/androidusb.html)，但是文章的最后也说了，这个办法是有遗憾的，就是`没法在Android上科学上网了`。接下来就介绍另外一种方法来弥补这个遗憾，即让没有任何网络连接（没插卡、没wifi、开飞行模式）的Android设备通过usb连接电脑即可上网，同时还可以兼容各种网络代理。\n<!-- more -->\n## 操作步骤\n废话不多说，先讲怎么作。需要的东西就两样，[adb](https://developer.android.com/tools/adb)和[sing-box](https://sing-box.sagernet.org/)（写这篇博客的时候，sing-box的版本是1.8.7）。\n1. 电脑上下载adb和sing-box。下载之后解压就好了，都是不需要安装的。\n2. 手机上安装sing-box的apk。\n3. 分别保存下面的配置文件到手机和电脑\n\n<details>\n<summary>手机端配置文件</summary>\n\n```json\n{\n  \"dns\": {\n    \"servers\": [\n      {\n        \"tag\": \"dns_114\",\n        \"address\": \"114.114.114.114\",\n        \"strategy\": \"ipv4_only\",\n        \"detour\": \"out_socks\"\n      }\n    ]\n  },\n  \"inbounds\": [\n    {\n      \"type\": \"tun\",\n      \"tag\": \"tun-in\",\n      \"interface_name\": \"tun0\",\n      \"inet4_address\": \"172.19.0.1/30\",\n      \"inet6_address\": \"fdfe:dcba:9876::1/126\",\n      \"auto_route\": true,\n      \"strict_route\": true\n    }\n  ],\n  \"outbounds\": [\n    {\n      \"type\": \"direct\",\n      \"tag\": \"direct\"\n    },\n    {\n      \"type\": \"dns\",\n      \"tag\": \"dns-out\"\n    },\n    {\n      \"type\": \"socks\",\n      \"tag\": \"out_socks\",\n      \"server\": \"127.0.0.1\",\n      \"server_port\": 1080,\n      \"udp_over_tcp\": true\n    }\n  ],\n  \"route\": {\n    \"rules\": [\n      {\n        \"protocol\": \"dns\",\n        \"outbound\": \"dns-out\"\n      },\n      {\n        \"port\": 53,\n        \"outbound\": \"dns-out\"\n      }\n    ],\n    \"final\": \"out_socks\",\n    \"auto_detect_interface\": true,\n    \"override_android_vpn\": true\n  }\n}\n```\n</details>\n\n<details>\n<summary>电脑端配置文件</summary>\n\n```json\n{\n    \"inbounds\": [\n        {\n            \"type\": \"socks\",\n            \"tag\": \"socks-in\",\n            \"listen\": \"127.0.0.1\",\n            \"listen_port\": 1280\n        }\n    ],\n    \"outbounds\": [\n        {\n            \"type\": \"direct\",\n            \"tag\": \"direct\"\n        },\n        {\n            \"type\": \"block\",\n            \"tag\": \"block\"\n        },\n        {\n            \"type\": \"dns\",\n            \"tag\": \"dns-out\"\n        }\n    ],\n    \"route\": {\n        \"rules\": [\n            {\n                \"protocol\": \"dns\",\n                \"outbound\": \"dns-out\"\n            },\n            {\n                \"port\": [\n                    53\n                ],\n                \"outbound\": \"dns-out\"\n            }\n        ],\n        \"final\": \"out_socks\"\n    }\n}\n```\n</details>\n\n4. 导入配置文件到手机上的sing-box内，运行\n5. 电脑上执行\n```shell\nsing-box run -c config.json\n```\n6. 电脑上再开一个命令窗口，执行\n```shell\nadb reverse tcp:1080 tcp:1280\n```\n\nDONE\n如无意外，这个时候手机已经正常打开网页了🎉🎉🎉\n有些app会有异常，是因为它们直接判断了设备既没连接wifi也没连接数据网络。\n\n## 大致原理\n很简单，上网可以非常简略地分为两步：\n1. 通过dns查询域名获取ip\n2. 和这个ip对应的服务器建立连接\n\n第6步adb就是把手机的1080端口映射到电脑的1280端口，即访问手机的1080端口就等同于访问电脑的1280端口。\n电脑上sing-box就是在本地127.0.0.1:1280上开了一个socks5的代理，规则是dns流量和目的地是53端口的流量通过dns的outbounds出去，其余流量最终走out_socks出去，即前面开的socks5代理，默认就是direct直连。\n来到Android这边，Android这边提供了一个114的dns，通过out_socks出去，dns本身是udp流量，所有在out_socks的socks代理上打开了udp_over_tcp。\n\n原理很简单，配置文件我也尽量精简，应该很容易看明白。如果有其他代理分流的需求，根据sing-box的文档再修改配置文件即可。这就比[gnirehtet](https://github.com/Genymobile/gnirehtet)灵活多了😁。","tags":["Android"],"categories":["玩机"]},{"title":"给avd模拟器安装magisk","url":"/2022/install_magisk_on_avd/","content":"\n想给avd安装magisk，查了一下，多是针对三方模拟器的，github上有一个项目[MagiskOnEmulator](https://github.com/shakalaca/MagiskOnEmulator)是可以针对avd的，然而试了，不行。最终找到magisk项目本身就支持安装到avd（从24.3开始），命令是`build.py avd_patch ${镜像目录下的ramdisk.img}`。\n<!-- more -->\n\n具体没什么好说的，项目clone下来，运行命令，跟着报错信息一路解决就行了。我遇到的，需要注意的问题有如下这些：\n- 项目有submodule，注意更新\n- 保持网络通畅\n- 环境变量`ANDROID_SDK_ROOT`\n- avd要运行起来\n\n安装完成之后，冷重启avd就行了。第一次启动，magisk可能提示要修复，确认就行了。再重启一次就OK了。","tags":["Android","Magisk"],"categories":["开发"]},{"title":"利用KDE Connect和NirCmd，在手机上控制电脑看小说","url":"/2022/control_PC_by_Phone_with_in_KDE_Connect_and_NirCmd/","content":"\n## 背景\n我经常看小说，然后为了自己的颈椎和眼睛的健康考虑，在电脑上看肯定是比手机上看更好。为此也是花了很多工夫，还写过几个油猴脚本和AHK脚本，但这些都不是这次的主题。\n然后还是从健康的角度出发，一直坐着也不太好，本来腰椎就不好，所以最好还是经常站起来。那么问题来了，站起来的时候，手不好操作键盘啊。为此我还买了一个mini键盘，6个按键的，可以自己设置键值。但是这个键盘是有线的，不太方便。\nKDE Connect也用了一段时间了，它支持在手机上执行电脑上预设好的命令。今天又发现这些命令是可以复制成URL（`kdeconnect://runcommand/***`）的，这好像是scheme啊，这是不是意味着可以通过外部程序来调用呢？然后试了一下，果然可以，那么基础条件就都齐了。\n<!-- more -->\n\n## 实现\n思路就是**翻页器App**通过scheme调用**手机上的Kde**执行**电脑上的kde**的各种预定义的**NirCmd**的命令。然后就是从尾到头，一步一步来。\n### NirCmd\n[NirCmd](https://www.nirsoft.net/utils/nircmd.html)是一个非常**强大**的Windows命令行工具，具体有多强大，可以看[完整文档](https://www.nirsoft.net/utils/nircmd2.html#using)。\n下载，解压，直接丢到`c:\\windows\\`目录下就行了。\n这次的目的是看小说，那基本上就只需要实现一个功能，就是模拟`PageUp`、`PageDown`、`➡️`和`⬅️`按键，相应的命令就是`nircmd sendkeypress pageup|pagedown|right|left`。\n\n### 电脑上的KDE Connect\n[KDE Connect](https://kdeconnect.kde.org)的[下载](https://kdeconnect.kde.org/download.html)[安装](https://userbase.kde.org/KDEConnect/zh-hans#.E5.AE.89.E8.A3.85)和基本使用方法我就不讲了，挺简单的。\n然后添加命令，如下操作：\n选取已连接的手机，打开插件设置\n![选取已连接的手机，打开插件设置](https://raw.githubusercontent.com/chenyue404/image_storage/main/2022-05-02_20-52-13.png)  \n\n打开执行命令的设置，添加命令\n![打开执行命令的设置，添加命令](https://raw.githubusercontent.com/chenyue404/image_storage/main/2022-05-02_20-53-40.png)\n\n### 手机上的KDE Connect\n安装，连接电脑，打开**运行命令**页面\n![](https://raw.githubusercontent.com/chenyue404/image_storage/main/20220502210357.jpg)\n\n长按命令复制URI\n![长按命令复制URI](https://raw.githubusercontent.com/chenyue404/image_storage/main/20220502210401.jpg)\n\n### 翻页器App\n就是在屏幕上放俩按钮，点击事件分别是PageUp和PageDown，长按事件是Left和Right。\n核心代码就是执行KDE Connect提供的scheme，代码如下\n```Kotlin\nstartActivity(Intent(Intent.ACTION_VIEW, command.toUri()))\n```\n当然App我已经写好了，直接[下载](https://github.com/chenyue404/PageTurner/releases)安装就好了。\n运行，在配置页面填上从KDE Connect复制的对应命令的URI，然后保存就行了。\n然后点击上、下按钮就可以触发电脑上的翻页动作了。\n\n## 总结\n虽然这次的目的是看小说，所以只做了翻页相关操作。但实际上是可以运行更多命令的，道理是一样的，调整手机上的布局和命令就行了。灵活一点的话，直接用Tasker画场景就好了，就不用单独写一个翻页器来操作了。","tags":["Android","Windows","KDE Connect","NirCmd"],"categories":["玩机"]},{"title":"QTTabBar打开最后一个不是单文件夹的路径","url":"/2021/open_the_last_path_that_is_not_a_single_folder_qttabbar/","content":"在浏览代码的时候，经常遇到包名文件夹，需要一层一层点进去，很麻烦，所以写了个QTTabBar的脚本来解决这个问题。效果就是打开前面对象的，最深一个，非单文件夹的路径。\n\n将[这个链接](https://gist.github.com/chenyue404/a450719f3a57ce76485cec30a7728648#file-)保存为js文件，放到电脑上合适的地方，然后拖放到QTTabBar的命令栏上。点击即可运行。  \n\n默认作用对象是当前文件夹，如果当前选中的项目是单个文件夹，则作用对象是选中文件夹。\n\n拖放之后，可以编辑图标、快捷键等信息。","tags":["Windows","QTTabBar"],"categories":["玩机"]},{"title":"windows清除默认打开方式","url":"/2021/clear_default_open_on_windows/","content":"以js文件为例，注册表俩地方  \n\n1. `计算机\\HKEY_CLASSES_ROOT\\.js`\n默认项的数据数值改回`JSFile`\n2. `计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.js\\OpenWithProgids`\n只保留默认和JSFile，其他的项删了","tags":["Windows"],"categories":["玩机"]},{"title":"解决53端口被svchost.exe占用的问题","url":"/2021/solve_the_problem_that_port_53_is_occupied_by_svchost/","content":"今天本地跑的dns服务突然报错了，跑不起来了，看下错误日志，53端口被占用了，蛋疼。  \n<!-- more -->\n## 1. 找到是谁占用的  \n第一想法就是找到是谁在占用，干掉它就行了。这个简单，google一下就知道怎么查找端口占用的软件了，我用的ip雷达。然而，我想简单了，发现占用的进程是scvhost.exe，是windows系统进程，这可不能随便干掉。  \n## 2. 找出元凶\nscvhost肯定不是真正凶手，继续挖。虽然进程名字是scvhost，但这不是关键，记住这个进程的pid。打开任务管理器，点到**服务**tab，找到pid对应的服务，发现了，是**Internet Connection Sharing (ICS)**  \n## 3. 干掉凶手\n好了，找到是谁了，直接干掉它！打开windows的服务，找到Internet Connection Sharing (ICS)，停止。咦，报错了\n```\n---------------------------\n服务\n---------------------------\nWindows 无法停止 Internet Connection Sharing (ICS) 服务(位于 本地计算机 上)。\n服务并未返回错误。这可能是一个 Windows 内部错误或服务内部错误。\n如果问题持续存在，请与你的系统管理员联系。\n---------------------------\n确定   \n---------------------------\n```\n\n无法停止这个服务怎么办？Google一下，发现这个服务是跟**主机网络服务**关联的，那么先去停止**主机网络服务**。  \n咦，停止了，又自动启动了。没办法，先禁用，然后停止**Internet Connection Sharing (ICS)**。好了，再看一下，53端口被释放了。好了，为了避免未知的错误，还是调过头来，把**主机网络服务**设置回`手动`。  \n\n\n问题解决😎","tags":["Windows"],"categories":["玩机"]},{"title":"给命令行设置代理","url":"/2021/set_proxy_for_terminal/","content":"\n最近在搞Flutter。我觉得整体还是不太成熟，表现之一就是在Android Studio里面编译运行的时候不能设置代理。Android开发的话，直接给gradle设置代理就行了，然而Flutter不支持直接设置代理，至少我没找到方法。那么在国内这种特色网络环境下，我又不喜欢用镜像仓库，怎么做Flutter开发呢？  \n<!-- more -->\n**用命令行编译，然后给命令行设置代理。**  \n\n下面记录一下给命令行设置代理的方法  \n\n#### Windows\n```shell\nset http_proxy=http://127.0.0.1:1081\nset https_proxy=http://127.0.0.1:1081\n\nset http_proxy_user=user\nset http_proxy_pass=pass\n\nset https_proxy_user=user\nset https_proxy_pass=pass\n\nset http_proxy=\nset https_proxy=\n```\n\n#### Linux\n```shell\nexport ALL_PROXY=\"socks5://192.168.99.110:1080\"\nexport all_proxy=\"socks5://192.168.99.110:1080\"\n\nunset ALL_PROXY\nunset all_proxy\n```\n\n\n","tags":["Windows","Linux"],"categories":["开发"]},{"title":"Win10给右键菜单添加“在此处打开命令窗口（管理员）”","url":"/2020/add_cmd_in_right_menu_on_windows10/","content":"\n在win10的桌面上，按住shift，并点击右键，就会发现比不按shift的时候，多了两个选项：“在此处打开命令行窗口”和“在此处打开PowerShell窗口”，很是方便。但是，有些时候，我们需要用管理员权限打开命令行窗口进行某些操作，怎么办？以前的方法是：打开开始菜单，输入cmd，可以看到“命令提示符”，右键-以管理员身份运行。然后再一路cd到需要操作的路径。那有没有更简单的办法呢？有的。\n<!-- more -->\nwin+r，输入“regedit”，打开注册表编辑器，定位到“\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell”，可以看到shell下面有一个cmd和一个Powershell，这俩就是我们在右键菜单里看到的“在此处打开命令行窗口”和“在此处打开PowerShell窗口”，那怎么增加一个“在此处打开命令窗口（管理员）”呢？\n\n1. 在shell上右键，新建-项，输入名字“runas”\n2. 选中runas，双击右侧的“默认”，将数值数据修改成“在此处打开命令窗口（管理员）”\n3. 在runas上右键，新建-项，名称command，双击右侧的“默认”，数值数据改成“`cmd.exe /s /k pushd \"%V\"`”\n4. 在runas上右键，新建-字符串值，名称填“Extended”，数值数据留空\n5. 在runas上右键，新建-字符串值，名称填“NoWorkingDirectory”，数值数据留空\n6. 在runas上右键，新建-DWOR(32位)值，数值名称ShowBasedOnVelocityId，数值数据639bc8\n\n4-6步，可以参考系统自带的cmd项，一摸一样地抄一遍就行了。\n完成，现在在桌面上按住shift并单击右键，即可看到多出来一个“在此处打开命令窗口（管理员）”。\n\n如果想要不按shift就可以看到，删除Extended项即可。\n如果想排序，在runas前面加上数字就行了。比如0cmd，1runas，这俩就会排到前面去。","tags":["Windows"],"categories":["玩机"]},{"title":"ItemTouchHelper的简单应用","url":"/2020/use_itemtouchhelper_simplely/","content":"\n新需求，表格显示照片，并可以拖动排序。\n第一反应，RecyclerView啊。那拖动怎么办？搜了一下，系统提供了ItemTouchHelper，直接用就行了。下面简单记录一下使用方法，及过程中遇到的一些问题。\n<!-- more -->\n## 使用方法\n### 首先先写好一个RecyclerView。\n以下是adapter的关键代码：固定第一个item用来显示拍照，其他item显示传入的数据\n```Kotlin\noverride fun getItemCount(): Int {\n    //加一显示第一个拍照item\n  return 1 + if (dataArray.isNullOrEmpty()) {\n        0\n  } else {\n        dataArray.size\n  }\n}\n\noverride fun onBindViewHolder(holder: ViewHolder, position: Int) {\n    //第一个固定显示拍照\n  if (position == 0) {\n        holder.tv_content.text = \"拍照\"\n  holder.tv_content.setBackgroundColor(\n            ContextCompat.getColor(\n                holder.itemView.context,\n                android.R.color.black\n  )\n        )\n        return\n  }\n\n    val dataPos = position - 1;\n    val text = dataArray[dataPos][0].toString()\n    val bgColor = ContextCompat.getColor(\n        holder.itemView.context,\n        dataArray[dataPos][1]\n    )\n    holder.tv_content.text = text\n    holder.tv_content.setBackgroundColor(bgColor)\n}\n```\n\n### 将ItemTouchHelper附加到RecyclerView上\n那我们就需要new一个ItemTouchHelper，而ItemTouchHelper需要传入一个ItemTouchHelper.Callback，接下来新建一个类继承子ItemTouchHelper.Callback\n```Kotlin\nclass MyItemTouchHelperCallback(val listener: MyTouchHelperListener) : ItemTouchHelper.Callback() {\n    override fun getMovementFlags(\n        recyclerView: RecyclerView,\n        viewHolder: RecyclerView.ViewHolder\n    ): Int {\n        val dragFlags =\n            ItemTouchHelper.UP or ItemTouchHelper.DOWN or ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT\n        val swipeFlags = ItemTouchHelper.LEFT\n        return makeMovementFlags(dragFlags, 0)\n    }\n\n    override fun onMove(\n        recyclerView: RecyclerView,\n        viewHolder: RecyclerView.ViewHolder,\n        target: RecyclerView.ViewHolder\n    ): Boolean {\n        listener?.onMove(viewHolder.adapterPosition, target.adapterPosition)\n        return true\n  }\n\n    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {\n    }\n\n    interface MyTouchHelperListener {\n        fun onMove(fromPos: Int, toPos: Int)\n    }\n}\n```\n必须重写3个方法：\n1. getMovementFlags\n控制Item往哪些方向可以拖，往哪些方向可以滑\n2. onMove\nItem移动的时候会被调用。我们在这里把它传到adapter里面，进行Item的交换。创建Listener，并在adapter里面实现\n```Kotlin\nclass ListAdapter(private val dataArray: Array<Array<Int>>) :\n    RecyclerView.Adapter<ListAdapter.ViewHolder>(),\n    MyItemTouchHelperCallback.MyTouchHelperListener {\n    //省略\n    override fun onMove(fromPos: Int, toPos: Int) {\n        notifyItemMoved(fromPos, toPos)\n    }\n}\n```\n3. onSwiped\nItem滑动的时候被调用。这个例子用不到。\n最后再把ItemTouchHelp附加到RecyclerView上\n```Kotlin\nItemTouchHelper(MyItemTouchHelperCallback(listAdapter)).attachToRecyclerView(rv_list)\n```\n\n好的，到这里为止，我们已经实现了拖拽交换item了。那么接下来还有哪些问题呢？\n\n## 各种问题\n\n### onMove一直被调用\n拖拽交换item不是UI交换就完事了，数据也是需要变的。然而我们发现这个onMove方法一直在调用，本地临时数据倒无所谓，一直更改也没什么，但是我们是需要提交网络的，总不能一直提交吧？\n重写ItemTouchHelper.Callback的clearView方法，这个方法会在所有手势和动画完成之后被调用，第一次onMove的时候记录开始的位置，clearView的时候记录结束的位置，然后再处理数据。\nMyItemTouchHelperCallback\n```Kotlin\noverride fun clearView(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder) {\n    super.clearView(recyclerView, viewHolder)\n    listener.onEnd(viewHolder.adapterPosition)\n}\n\ninterface MyTouchHelperListener {\n    fun onMove(fromPos: Int, toPos: Int)\n    fun onEnd(endPos: Int)\n}\n```\nListAdapter\n```Kotlin\nprivate var startDataPos = -1 \nprivate var endDataPos = -1 \noverride fun onMove(fromPos: Int, toPos: Int) {\n    notifyItemMoved(fromPos, toPos)\n    startDataPos = fromPos - 1\n}\n\noverride fun onEnd(endPos: Int) {\n    endDataPos = endPos - 1;\n    //处理数据，脚标归零\n    dataArray[startDataPos] = dataArray[endDataPos].also {\n      dataArray[endDataPos] = dataArray[startDataPos]\n    }\n    startDataPos = 0\n    endDataPos = 0 \n}\n```\n\n### 第一个item不能拖动\n第一个位置是用来显示拍照的，不能和普通照片一样被拖动，怎么办？\n两个办法：\n1. 在getMovementFlags里面判断，根据MyTouchHelperListener新增一个方法通过ListAdapter返回bool值，或者根据viewHolder的位置，来判断能不能拖拽。\n2. 重写ItemTouchHelper.Callback的isLongPressDragEnabled方法，返回false，禁止长按拖拽。再给item添加长按事件，调用ItemTouchHelper.startDrag来开启拖拽。\n\n### 第一个item不能被移动\n第一个位置同样不应该能被其他的item挤走，怎么办？\n这个好说，也是两个办法：\n1. 重写canDragOver，返回false即可。具体什么时候返回false，参考上面一个问题的方法1\n2. 更简单一点，接收到toPos是0，就不交换UI\n\n### 怎么在长按的时候显示删除按钮\n要求长按的时候，不仅可以拖动，而且在所有item的右上角显示删除按钮，就像手机桌面一样，怎么整？\n更改flag值，notifydatachanged？肯定不行啊，这个方法要把所有item重新测量，布局的，拖拽的手势就打断了，item就回到原位了，而且整个RecyclerView都会闪一下。\n解决办法就是，先默认不允许长按拖动，再监听item的长按事件，长按的时候调用ItemTouchHelper.startDrag来开启拖拽。那怎么显示删除按钮呢？直接用RecyclerView来获取所有ViewHolder，直接操作ViewHolder，显示出删除按钮。\n\n---\n好的，以上就是我这次使用ItemTouchHelper的过程了。\ndemo代码在这里[https://github.com/chenyue404/ItemTouchHelperDemo](https://github.com/chenyue404/ItemTouchHelperDemo)","tags":["Android"],"categories":["开发"]},{"title":"Android上各种App的去广告姿势","url":"/2020/remove_app_ads_on_android/","content":"## Adguard\n<!-- more -->\n```\n||pstatp.com/obj/ad-pattern^\n||snssdk.com/api/ad^\n||api.xiachufang.com/v2/ad^\n||restapi.ele.me/lego/new_splash_screen^\n```\n\n## host\nAdAday的默认列表先来一个\n\n| 应用 | 域名 |\n| --- | --- |\n|铁路12306|ad.12306.cn|\n|搜书大师|snssdk.com|\n|下厨房|api.xiachufang.com/v2/ad/*|\n\n## Activity\n```shell\nadb shell am start -n *\n```\n| 应用 | Activity | 是否需要root |\n| --- | --- | --- |\n|搜书大师|com.flyersoft.seekbooks/com.flyersoft.seekbooks.ActivityMain|是|\n|饿了么|me.ele/me.ele.application.ui.home.HomeActivity|是|\n|招商银行|长按图标，点击“账户”进入|否|\n|     |浏览器打开`javascript:window.location.href='cmbmobilebank://cmbls/functionjump?id=1&action=gofuncid&funcid=6001003&keeponPath=true&source=today';`|否 |","tags":["Android"],"categories":["玩机"]},{"title":"不知道第几个博客","url":"/2020/zero/","content":"已经记不得是第几个blog了，建了，死了，不管了。这个还是好好写吧。\nmarkdown，简简单单地写。","categories":["日常"]}]